# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

EQdyna.2Dcycle is a 2D finite element method (FEM) code for simulating physics-based multicycle earthquake dynamics on geometrically complex fault systems. The codebase consists of:

- **Core simulation engine**: Fortran 90 source code in `src/` 
- **Case management**: Python scripts for creating and configuring simulation cases
- **Post-processing**: Python utilities for plotting and analysis
- **Test suites**: Reference results and validation tools

## Build and Installation

### Install dependencies and build executable:
```bash
# For macOS (sets up environment and builds)
./install.eqdyna.2dcycle.sh -e macos

# For Ubuntu/Linux
./install.eqdyna.2dcycle.sh -m ubuntu

# Just build (assumes dependencies exist)
./install.eqdyna.2dcycle.sh -m macos
```

### Manual build:
```bash
cd src/
make
cd ..
mkdir bin
mv src/eqdyna.2dcycle bin/
```

### Environment setup:
```bash
# Source to set environment variables
source install.eqdyna.2dcycle.sh
```

This sets `EQDYNA2DCYCLEROOT` and adds `bin/` and `scripts/` to PATH.

## Running Simulations

### Create a new case:
```bash
create.newcase /path/to/new/case test.subei
cd /path/to/new/case
```

### Configure and run:
```bash
# Edit user_defined_params.py to set simulation parameters
case.setup  # Creates FE_*.txt input files and FE_run.sh
chmod +x FE_run.sh
./FE_run.sh  # Runs simulation and generates plots
```

### Multi-cycle simulations:
```bash
python3 runCycle.py  # For earthquake cycle simulations
```

## Testing

### Run validation tests:
```bash
python3 check.test.py  # Compares results against reference data
```

## Key File Types and Architecture

### Core Fortran Source (`src/`)
- `eqdyna2d.f90`: Main program entry point
- `globalvar.f90`: Global variables and data structures
- `driver.f90`: Main simulation driver
- `faulting.f90`, `fric.f90`: Fault mechanics and friction laws
- `meshgen.f90`, `meshgen1.f90`: Mesh generation
- `qdct*.f90`: Finite element routines (2D/3D quadrilateral elements)
- `contm*.f90`: Contact mechanics
- `interstress.f90`: Interseismic stress calculations

### Case Configuration
- `compset/`: Pre-configured test cases (test.saf, test.subei)
- `user_defined_params.py`: Simulation parameters (inherits from defaultParameters.py)
- `userDefinedFaultSysGeoPhys.py`: Fault geometry and physics
- `FE_*.txt`: Input files generated by case.setup

### Python Utilities (`scripts/`)
- `case.setup`: Generates input files from user_defined_params.py
- `create.newcase`: Creates new simulation case from compset template
- `plotRuptureDynamics`: Post-processing visualization
- `meshGenLib.py`: Mesh generation utilities
- `defaultParameters.py`: Default simulation parameters

### Output Files
- `totalop.txt*`: Main simulation output files (stress, slip, rupture time)
- `cyclelog.txt*`: Earthquake cycle logging
- `interval.txt*`: Inter-event intervals
- `aRawSimuData/`: Directory containing raw simulation results
- `aPlots/`: Generated plots and figures

## Code Architecture

### Simulation Workflow
1. **Case Setup**: Configure parameters in `user_defined_params.py`
2. **Input Generation**: Run `case.setup` to create FE_*.txt files
3. **Mesh Generation**: Fortran code generates finite element mesh
4. **Fault Loading**: Apply tectonic loading and build up stress
5. **Dynamic Rupture**: Simulate earthquake rupture dynamics
6. **Post-Processing**: Generate plots and analyze results

### Key Components
- **Friction Laws**: Multiple friction models (friclaw parameter)
- **Mesh Types**: Structured/unstructured quadrilateral elements
- **Fault Geometry**: Complex multi-segment fault systems
- **Loading**: Quasi-static interseismic loading with viscosity
- **Output**: Time series of stress, slip, and rupture properties

### Parameter Management
Parameters flow from `defaultParameters.py` → `user_defined_params.py` → `case.setup` → FE_*.txt input files. The `par` object contains all simulation parameters including mesh resolution, friction coefficients, material properties, and fault geometry.

## Dependencies
- **Fortran**: gfortran compiler
- **Python 3**: numpy, matplotlib, xarray
- **Optional**: gmsh, meshio, nbconvert (for advanced meshing)

## Translation Notes
When translating MATLAB code to Python, maintain identical algorithms, file names, and code structure. Focus on line-by-line equivalence while adapting syntax for Python conventions.